// ech0(await qtApi.account.getServerTime());
// ech0(await qtApi.account.getServerTime());
// }

// async function testingOrDebugging() {
//   const apiOptions: ApiOptions = {
//     debug: 100,
//     token: getMyToken,
//   };

//   const { qtApi } = await qtAPIv2_0(apiOptions);
// const setImmediatePromise = promisify(setImmediate);

// void setImmediatePromise;
/* promisify(setImmediate)( */

// {
// console.log(c1++, '----STEP 2----MAP-1-1-1', i1);

// return async
// }
// #region : as
//     {
//     // console.log(c2a++, '-$---STEP 8-m1-ISymbolSearchResult');
//     // const [ref] /* : ISymbolSearchResult */ =
//     await
//       item,
//     );
//     // console.log(c2b++, '----STEP 10-m1-ISymbolSearchResult');

//     // const {
//     //   // all /*  ISymbolSearchResult[]; */,
//     //   // count /*  number; */,
//     //   currency /*  Currency; */,
//     //   description /*  string; */,
//     //   isQuotable /*  boolean; */,
//     //   isTradable /*  boolean; */,
//     //   listingExchange /*  string; */,
//     //   securityType /*  string; */,
//     //   symbol /*  string; */,
//     //   symbolId /*  number; */,
//     // } = ref || {
//     //   // all /*  ISymbolSearchResult[]; */,
//     //   // count /*  number; */,
//     //   currency: 'CAD',
//     //   description: '' /*  string; */,
//     //   isQuotable: false /*  boolean; */,
//     //   isTradable: false /*  boolean; */,
//     //   listingExchange: '' /*  string; */,
//     //   securityType: '' /*  string; */,
//     //   symbol: 'N/A' /*  string; */,
//     //   symbolId: 1 /*  number; */,
//     // };

//     // const partial: ISymbolSearchResult = {
//     //   // all:[] /*  ISymbolSearchResult[]; */,
//     //   // count /*  number; */,
//     //   currency /*  Currency; */,
//     //   description /*  string; */,
//     //   isQuotable /*  boolean; */,
//     //   isTradable /*  boolean; */,
//     //   listingExchange /*  string; */,
//     //   securityType /*  string; */,
//     //   symbol /*  string; */,
//     //   symbolId /*  number; */,
//     // };

//     return echo1(`'qtApi.search.stock(${item})':`, ref)?.symbolId || 1;
//   };
// })
// #endregion :

// .map((item, i2) => {
//   console.log(c3++, '----STEP 3----MAP-2-2-2', i2);

//   return async () => {
//     console.log(c4++, '----STEP 7-m2-');

//     return item().then(xItem => {
//       console.log(c5++, '-$2---STEP 11-m2-');

//       return qtApi.getSymbols.byStockIds([xItem]);
//     });
//   };
// });
// .map((item, i3) => {
//   console.log(c6++, '----STEP 4----MAP-3-3-3', i3);

//   return async () => {
//     console.log(c7a++, '----STEP 6-m3-');
//     const returnValue = echo1('getSymbols.byStockIds:', await item());
//     console.log(c7b++, '----STEP 12-m3-');

//     return returnValue;
//   };
// })
// .map((item, i4) => {
//   console.log(c8a++, '----STEP 5---MAP-4-4-4', i4);
//   const returnValue = item();
//   console.log(c8b++, '----STEP 9---MAP-4-4-4', i4);

//   return returnValue;
// });



// mongoose.connect('mongodb://0.0.0.0:27017/users_test', {
//   useNewUrlParser: true,
//   useUnifiedTopology: true,
// });

// const db = mongoose.connection;
// db.on('error', console.error.bind(console, 'connection error:'));
// db.once('open', function () {
//   console.log.bind(console, "we're connected!");
//   // we're connected!
//   db.close();
// });

// void mongo;
// ech0(mongo);
// % Rest operations
// # ACCOUNT CALLS
void getActivities; /* ACCOUNTS/:ID/ACTIVITIES*/
void getOrders; /* ACCOUNTS/:ID/ORDERS*/
void getOrdersByIds; /* ACCOUNTS/:ID/ORDERS*/
void getExecutions; /* ACCOUNTS/:ID/EXECUTIONS*/
void getBalances; /* ACCOUNTS/:ID/BALANCES*/
void getPositions; /* ACCOUNTS/:ID/POSITIONS*/
void getAllAccounts; /* ACCOUNTS*/
void getTime; /* ACCOUNTS*/
void getCandles;

/*

    GET MARKETS/QUOTES/STRATEGIES
    GET MARKETS/QUOTES/OPTIONS
    GET MARKETS/QUOTES/:ID
    GET MARKETS
    GET SYMBOLS/:ID/OPTIONS
    GET SYMBOLS/SEARCH
    GET SYMBOLS/:ID
  */
// const some = new Symbol();
// void some;
// const qtApi = await mainRedis();
// id0(await willGetSNP500StringList())
//   .map(item => qtApi.search.stock(item))
//   .map(async item => (await item)[0])
//   .map(async symbol => new Symbol(await symbol))
//   .map(async document => (await document).save())
//   .map(async somex => void0(await somex));


// const user = {
//   name: 'redis-json',
//   age: 25,
//   address: {
//     doorNo: '12B',
//     locality: 'pentagon',
//     pincode: 123456,
//   },
//   cars: ['BMW 520i', 'Audo A8'],
// };

// await jsonCache.set('123', user);

// await jsonCache.get('123');

/*
import Redis from 'ioredis';
import JSONCache from 'redis-json';

const redis = new Redis() as any;

const jsonCache = new JSONCache<{
  name: string;
  age: number;
  address: {
    doorNo: string;
    locality: string;
    pincode: number;
  }
}>(redis, {prefix: 'cache:'});

const user = {
  name: 'redis-json',
  age: 25,
  address: {
    doorNo: '12B',
    locality: 'pentagon',
    pincode: 123456
  },
  cars: ['BMW 520i', 'Audo A8']
}

await jsonCache.set('123', user)

await jsonCache.get('123')
// output
// {
//   name: 'redis-json',
//   age: 25,
//   address: {
//     doorNo: '12B',
//     locality: 'pentagon',
//     pincode: 123456
//   },
//   cars: ['BMW 520i', 'Audo A8']
// }

await jsonCache.set('123', {gender: 'male'})
await jsonCache.get('123')
// output
// {
//   name: 'redis-json',
//   age: 25,
//   address: {
//     doorNo: '12B',
//     locality: 'pentagon',
//     pincode: 123456
//   },
//   cars: ['BMW 520i', 'Audo A8']
//   gender: 'male'
// }

await jsonCache.get('123', 'name', 'age');
// output
// {
//   name: 'redis-json',
//   age: 25,
// }

await jsonCache.get('123', 'name', 'address.doorNo');
// {
//   name: 'redis-json',
//   address: {
//     doorNo: '12B'
//   }
// }

await jsonCache.clearAll();

await jsonCache.get('123');
// undefined


await jsonCache.incr('123', {age: 1}) // increments age by 1
With custom stringifier and parser:

const jsonCache = new JSONCache(redis, {
  stringifier: {
    Date: (val: Date) => val.toISOString()
  },
  parser: {
    Date: (str: string) => new Date(str)
  }
})

const date = new Date()
await jsonCache.set('test', {
  date: date
})

// Redis hashset
> hgetall jc:test /// data
1) "date"
2) "2020-05-17T14:41:45.861Z"
> hgetall jc:test_t /// type info
1) "date"
2) "Date"


const result = await jsonCache.get('test')
result.date == date /// true
With transactions:

const transaction = redisClient.multi();

transaction
  .set('name', 'foo')
  .set('bar', 'baz')

jsonCache.setT(transaction, 'test', {name: 'testing'})
jsonCache.delT(transaction, 'test1')
jsonCache.rewriteT(transaction, 'test2', {name: 'testing', age: 25})

transaction
  .exec(function(err, replies) => {
    /// your logic here after
  })
 */

// Please note that only setT(), rewriteT() & delT() supports transaction, where as get() & clearAll() do NOT support transaction because we process those results before returning it to the calling function. Moreover there is no real usecase in adding get methods to a transaction!

// defineProperty(
//   target: T,
//   p: PropertyKey,
//   attributes: PropertyDescriptor,
// ): any {
//   if (this.handlerOptions.debug === true) {
//     void echo<unknown>(
//       'PROXY:',
//       '!!→ defineProperty',
//       'target →',
//       target,
//       'p →',
//       p,
//       'attributes →',
//       attributes,
//     );

//     echo('redisClientProxyHandlerClass');
//   }
//   return Reflect.defineProperty(target, p, attributes);
// }

// getOwnPropertyDescriptor(
//   target: T,
//   p: PropertyKey,
// ): PropertyDescriptor | undefined {
//   if (this.handlerOptions.debug === true) {
//     void echo<unknown>(
//       'PROXY:',
//       '!!→ getOwnPropertyDescriptor',
//       'target →',
//       target,
//       'p →',
//       p,
//     );

//     echo('redisClientProxyHandlerClass');
//   }
//   return Reflect.getOwnPropertyDescriptor(target, p);
// }

// set(target: T, p: PropertyKey, value: any, receiver: any): boolean {
//   if (this.handlerOptions.debug === true) {
//     void echo<unknown>(
//       'PROXY:',
//       '!!→ set',
//       'target →',
//       target,
//       'p →',
//       p,
//       'value →',
//       value,
//       'receiver →',
//       receiver,
//     );

//     echo('redisClientProxyHandlerClass');
//   }

//   return Reflect.set(target, p, value, receiver);
// }

// get(target: T, p: PropertyKey, receiver: any): any {
//   if (this.handlerOptions.debug === true) {
//     void echo<unknown>(
//       'PROXY:',
//       '!!→ get',
//       'target →',
//       target,
//       'p →',
//       p,
//       'receiver →',
//       receiver,
//     );

//     echo('redisClientProxyHandlerClass');
//   }

//   return Reflect.get(target, p, receiver);
// }

// void echo('URL_HASH_HEX:', proxyData.URL_HASH_HEX);
// void echo('DATA_HASH_HEX:', proxyData.DATA_HASH_HEX);
// void echo('URLDATA_HEX:', proxyData.URLDATA_HEX);
// void echo('URL_PATH:', proxyData.URL_PATH);
// void ech0('no redis write');

// void0(
//   await this.tedis.command(
//     'PFADD',
//     `count:${proxyData.URL_HASH_HEX}:data:unique`,
//     `${proxyData.DATA_HASH_HEX}`,
//   ),
// );

// void0(
//   await this.tedis.command(
//     'PFADD',
//     `count:${proxyData.URL_HASH_HEX}:data:same:${proxyData.URLDATA_HEX}`,
//     `${Date.now()}`,
//   ),
// );
/*
// TTL mykey
        setTimeout(async () => {
          echo<any>(myKey, await this.tedis.command('TTL', myKey));
        }, 1000);

        setTimeout(async () => {
          echo<any>(myKey, await this.tedis.command('TTL', myKey));
        }, 2000);
        setTimeout(async () => {
          echo<any>(myKey, await this.tedis.command('TTL', myKey));
        }, 3000);

         // echo(response);
      echo<any>('\nresponse.status:\n\n', response.status);
      echo('\nresponse.statusText', response.statusText);
      echo('\nresponse.headers', response.headers);
      echo(
        "\nresponse.headers['strict-transport-security']:\n\n",
        response.headers['strict-transport-security'],
      );
      echo(
        "\nresponse.headers['x-ratelimit-remaining']:\n\n",
        response.headers['x-ratelimit-remaining'],
      );
      echo(
        "\nresponse.headers['x-ratelimit-reset']:\n\n",
        response.headers['x-ratelimit-reset'],
      );
      echo(
        "\nresponse.headers['content-type']:\n\n",
        response.headers['content-type'],
      );
      echo(
        "\nresponse.headers['content-length']:\n\n",
        response.headers['content-length'],
      );
      echo<any>(
        '\nresponse.config as ClientRequestConfig:\n\n',
        response.config as ClientRequestConfig,
      );
      echo(
        '\n(response.config as ClientRequestConfig).headers:\n\n',
        (response.config as ClientRequestConfig).headers,
      );
      echo(
        '\n(response.config as ClientRequestConfig).url:\n\n',
        (response.config as ClientRequestConfig).url,
      );
      echo(
        '\n(response.config as ClientRequestConfig).method:\n\n',
        (response.config as ClientRequestConfig).method,
      );
      echo(
        '\n(response.config as ClientRequestConfig).headers.Accept:\n\n',
        (response.config as ClientRequestConfig).headers.Accept,
      );
      echo(
        '\n(response.config as ClientRequestConfig).headers.Authorization:\n\n',
        (response.config as ClientRequestConfig).headers.Authorization,
      );
      echo(
        '\n(response.config as ClientRequestConfig).headers.location:\n\n',
        (response.config as ClientRequestConfig).headers.location,
      );
      echo(
        "\nresponse.headers['x-ratelimit-remaining']:\n\n",
        response.headers['x-ratelimit-remaining'],
      );
      echo(
        "\nresponse.headers['x-ratelimit-reset']:\n\n",
        response.headers['x-ratelimit-reset'],
      );
      // echo(response.request);
      // echo(response.data);
 */
/*
export interface ClientResponse<T = any> {
  data: T;
  status: number;
  statusText: string;
  headers: any;
  config: ClientRequestConfig;
  request?: any;
}
  echo(response.headers['strict-transport-security']);
  echo(response.headers['x-ratelimit-remaining']);
  echo(response.headers['x-ratelimit-reset']);
  echo(response.headers['content-type']);
  echo(response.headers['content-length']);

   void proxyData;
      void this.tedis;
      // void ech0(proxyData.path);

      // Data exists in Redis ?
      // Yes: Get Data from Redis !
      // No: Get Data from ApiClient !
      //      Save Data in Redis !

      const myKey = proxyData.URL_HSH;
      const hash = [
        'URL_HSH:',
        proxyData.URL_HSH,
        'path:',
        proxyData.path,
        'DATA_HSH:',
        proxyData.DATA_HSH,
        'data:',
        proxyData.data,
        'URLDATA_HSH:',
        proxyData.URLDATA_HSH,
      ];

      // const convertArrayToObject = (array:any[], key:any) => {
      //   return array.reduce((obj: any, item: any, currentIndex,) => {
      //     array.length
      //     return {
      //       ...obj,
      //       [item[key]]: item,
      //     };
      //   }, initialValue);
      // };

      // void convertArrayToObject
      void0(await this.tedis.command('HSET', myKey, ...hash));
      void0(await this.tedis.command('EXPIRE', myKey, 300));
      echo<any>(myKey, await this.tedis.command('TTL', myKey));
      ech0(await this.tedis.command('TTL', myKey));

      const parsed = id0(
        parser<any[]>(await this.tedis.command('HGETALL', myKey)),
      );
      const initialValue: any = {};
      for (let i = 0; i < parsed.length; i += 2) {
        initialValue[parser((parsed[i] as string).split(':')[0])] =
          parsed[i + 1];
      }
      // const returnedData =

      // ech0(parser(initialValue['data']));
      // await this.tedis.command('HSET', ...hash);
      // const alternativeReturnValue = {
      //   data: returnedData,
      //   status: 200,
      //   statusText: 'OK',
      // };
      // void alternativeReturnValue;
      //      Then return the Data ...
      const response: ClientResponse = await returnValue;
      void response;

      return returnValue;

      // + echo(response.headers['x-ratelimit-remaining']);
      // + echo(response.headers['x-ratelimit-reset']);

      // + echo(response.config as ClientRequestConfig);
      // + echo((response.config as ClientRequestConfig).headers);
      // + echo((response.config as ClientRequestConfig).url);
      // + echo((response.config as ClientRequestConfig).method);
      // + echo((response.config as ClientRequestConfig).headers.Accept);
      // + echo((response.config as ClientRequestConfig).headers.Authorization);
      // + echo((response.config as ClientRequestConfig).headers.location);
      // + echo(response.headers['x-ratelimit-remaining']);
      // + echo(response.headers['x-ratelimit-reset']);
      // + echo(response.headers);
      // echo(response.request);
      // echo(response.data);

Promise {
  {
    status: 200,
    statusText: 'OK',
    headers: {
      'x-ratelimit-remaining': '29970',
      'x-ratelimit-reset': '1611038234',
      'content-type': 'application/json; charset=utf-8',
      'content-length': '152',
      date: 'Tue, 19 Jan 2021 06:09:06 GMT',
    },
    config: {
      url: 'https://api06.iq.questrade.com/v1/accounts',
      }
       request: ClientRequest {}
          data: { accounts: [Array], userId: 126691 }
  }
}


Promise {
  {
    status: 200,
    statusText: 'OK',
    headers: {
      // 'strict-transport-security': 'max-age=31536000; includeSubDomains;',
      'x-ratelimit-remaining': '29970',
      'x-ratelimit-reset': '1611038234',
      'content-type': 'application/json; charset=utf-8',
      'content-length': '152',
      date: 'Tue, 19 Jan 2021 06:09:06 GMT',
      // connection: 'close'
    },
    config: {
      url: 'https://api06.iq.questrade.com/v1/accounts',
      method: 'get',
      data: null,
      headers: [Object],
      transformRequest: [Array],
      transformResponse: [Array],
      timeout: 0,
      adapter: [Function: httpAdapter],
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: [Function: validateStatus]
    },
    request: ClientRequest {
      _events: [Object: null prototype],
      _eventsCount: 7,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      destroyed: true,
      _last: true,
      chunkedEncoding: false,
      shouldKeepAlive: false,
      _defaultKeepAlive: true,
      useChunkedEncodingByDefault: false,
      sendDate: false,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: 0,
      _hasBody: true,
      _trailer: '',
      finished: true,
      _headerSent: true,
      _closed: true,
      socket: [TLSSocket],
      _header: 'GET /v1/accounts HTTP/1.1\r\n' +
        'Accept: application/json, text/plain, * /*\r\n' +
        'Authorization: Bearer gqE8gnBsUconvwHds0NAC4bJOSuFuloa0\r\n' +
        'location: \r\n' +
        'User-Agent: axios/0.21.1\r\n' +
        'Host: api06.iq.questrade.com\r\n' +
        'Connection: close\r\n' +
        '\r\n',
      _keepAliveTimeout: 0,
      _onPendingData: {},
      agent: [Agent],
      socketPath: undefined,
      method: 'GET',
      maxHeaderSize: undefined,
      insecureHTTPParser: undefined,
      path: '/v1/accounts',
      _ended: true,
      res: [IncomingMessage],
      aborted: false,
      timeoutCb: null,
      upgradeOrConnect: false,
      parser: null,
      maxHeadersCount: null,
      reusedSocket: false,
      host: 'api06.iq.questrade.com',
      protocol: 'https:',
      _redirectable: [Writable],
      [Symbol(kCapture)]: false,
      [Symbol(kNeedDrain)]: false,
      [Symbol(corked)]: 0,
      [Symbol(kOutHeaders)]: [Object: null prototype]
    },
    data: { accounts: [Array], userId: 126691 }
  }
}
Promise {
  {
    status: 200,
    statusText: 'OK',
    headers: {
      'strict-transport-security': 'max-age=31536000; includeSubDomains;',
      'x-ratelimit-remaining': '29969',
      'x-ratelimit-reset': '1611038234',
      'content-type': 'application/json; charset=utf-8',
      'content-length': '43',
      date: 'Tue, 19 Jan 2021 06:09:06 GMT',
      connection: 'close'
    },
    config: {
      url: 'https://api06.iq.questrade.com/v1/time',
      method: 'get',
      data: null,
      headers: [Object],
      transformRequest: [Array],
      transformResponse: [Array],
      timeout: 0,
      adapter: [Function: httpAdapter],
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: [Function: validateStatus]
    },
    request: ClientRequest {
      _events: [Object: null prototype],
      _eventsCount: 7,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      destroyed: true,
      _last: true,
      chunkedEncoding: false,
      shouldKeepAlive: false,
      _defaultKeepAlive: true,
      useChunkedEncodingByDefault: false,
      sendDate: false,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: 0,
      _hasBody: true,
      _trailer: '',
      finished: true,
      _headerSent: true,
      _closed: true,
      socket: [TLSSocket],
      _header: 'GET /v1/time HTTP/1.1\r\n' +
        'Accept: application/json, text/plain, * /*\r\n' +
        'Authorization: Bearer gqE8gnBsUconvwHds0NAC4bJOSuFuloa0\r\n' +
        'location: \r\n' +
        'User-Agent: axios/0.21.1\r\n' +
        'Host: api06.iq.questrade.com\r\n' +
        'Connection: close\r\n' +
        '\r\n',
      _keepAliveTimeout: 0,
      _onPendingData: {},
      agent: [Agent],
      socketPath: undefined,
      method: 'GET',
      maxHeaderSize: undefined,
      insecureHTTPParser: undefined,
      path: '/v1/time',
      _ended: true,
      res: [IncomingMessage],
      aborted: false,
      timeoutCb: null,
      upgradeOrConnect: false,
      parser: null,
      maxHeadersCount: null,
      reusedSocket: false,
      host: 'api06.iq.questrade.com',
      protocol: 'https:',
      _redirectable: [Writable],
      [Symbol(kCapture)]: false,
      [Symbol(kNeedDrain)]: false,
      [Symbol(corked)]: 0,
      [Symbol(kOutHeaders)]: [Object: null prototype]
    },
    data: { time: '2021-01-19T01:09:06.282000-05:00' }
  }
}
Questrade Server Time: 2021-01-19T06:09:06.282Z
Status: ready

Promise {
  {
    status: 200,
    statusText: 'OK',
    headers: {
      'strict-transport-security': 'max-age=31536000; includeSubDomains;',
      'x-ratelimit-remaining': '29968',
      'x-ratelimit-reset': '1611038234',
      'content-type': 'application/json; charset=utf-8',
      'content-length': '1582',
      date: 'Tue, 19 Jan 2021 06:09:06 GMT',
      connection: 'close'
    },
    config: {
      url: 'https://api06.iq.questrade.com/v1/symbols/search?prefix=COUCHE%20TARD&offset=0',
      method: 'get',
      data: null,
      headers: [Object],
      transformRequest: [Array],
      transformResponse: [Array],
      timeout: 0,
      adapter: [Function: httpAdapter],
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: [Function: validateStatus]
    },
    request: ClientRequest {
      _events: [Object: null prototype],
      _eventsCount: 7,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      destroyed: true,
      _last: true,
      chunkedEncoding: false,
      shouldKeepAlive: false,
      _defaultKeepAlive: true,
      useChunkedEncodingByDefault: false,
      sendDate: false,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: 0,
      _hasBody: true,
      _trailer: '',
      finished: true,
      _headerSent: true,
      _closed: true,
      socket: [TLSSocket],
      _header: 'GET /v1/symbols/search?prefix=COUCHE%20TARD&offset=0 HTTP/1.1\r\n' +
        'Accept: application/json, text/plain, * /*\r\n' +
        'Authorization: Bearer gqE8gnBsUconvwHds0NAC4bJOSuFuloa0\r\n' +
        'location: 51648972\r\n' +
        'User-Agent: axios/0.21.1\r\n' +
        'Host: api06.iq.questrade.com\r\n' +
        'Connection: close\r\n' +
        '\r\n',
      _keepAliveTimeout: 0,
      _onPendingData: {},
      agent: [Agent],
      socketPath: undefined,
      method: 'GET',
      maxHeaderSize: undefined,
      insecureHTTPParser: undefined,
      path: '/v1/symbols/search?prefix=COUCHE%20TARD&offset=0',
      _ended: true,
      res: [IncomingMessage],
      aborted: false,
      timeoutCb: null,
      upgradeOrConnect: false,
      parser: null,
      maxHeadersCount: null,
      reusedSocket: false,
      host: 'api06.iq.questrade.com',
      protocol: 'https:',
      _redirectable: [Writable],
      [Symbol(kCapture)]: false,
      [Symbol(kNeedDrain)]: false,
      [Symbol(corked)]: 0,
      [Symbol(kOutHeaders)]: [Object: null prototype]
    },
    data: { symbols: [Array] }
  }
}
       */

// : (resolve: (value: unknown) => void
// : (reason?: any) => void

new Promise((resolve, reject) => {
  resolve(0);
  reject();
});
setImmediate(() => 4);

promisify(setImmediate)();
// export function outerFunct(fn:any,cb:any) {
//   return null;
// }

/*
const fntocall= void0;
 const callBack = (cb: any) => {
       setImmediate( ()=>{

       cb(fntocall())
       })
    };

    return new Promise<any>((resolve, reject) => {
      callBack((error: Error, result: any) => {
        if (!error) {
          resolve(result);

          return true;
        }

        reject(error);

        return false;
      });
    });
---------------------------
setImmediate(callback: (...args: any[]) => void, ...args: any[]): NodeJS.Immediate

 const callBack = (cb: any) => {
      //
      this.enQueue({ ...value, cb });
      //
      if (this.isNotCalled) {
        this.callToPopQueue();
      }

      return null;
    };
immediateCallBack
   const immediateCallBack =  new Promise<any>((resolve, reject) => {
      setImmediate((error: Error, result: any) => {
        if (!error) {
          resolve(result);

          return true;
        }

        reject(error);

        return false;
      });
    });


  echo1(
        'getSymbols.byStockIds:',
        (await
item()
        )[0],
      ),
    )
   */
// snp500list.map(async item =>
//   echo1(
//     'getSymbols.byStockIds:',
//     (
//       await qtApi.getSymbols.byStockIds([
// await         item()
//     )[0],
//   ),
// );

/*
    .map( item => async()=>
      echo1(
        'getSymbols.byStockIds:',
        (
          await qtApi.getSymbols.byStockIds([
            echo1('symbolId:', (await qtApi.search.stock(item))[0])?.symbolId ||
              1,
          ])
        )[0],
      ),
    );
  ----
   echo1(
      'getSymbols.byStockIds:',
      (
        await qtApi.getSymbols.byStockIds([
          echo1('symbolId:', (await qtApi.search.stock(item))[0]?.symbolId) || 1,
        ])
      )[0],
    )
   */
// // export const cs
// snp500list
//   .map(stock => qtApi.search.stock(stock))
//   .map(stock =>
//     stock.then(s => {
//       try {
//         return s[0].symbolId;
//       } catch {
//         return 0;
//       }
//     }),
//   )
//   .map(t =>
//     t.then(sid => {
//       try {
//         return qtApi.getSymbols.byStockIds([sid]);
//       } catch {
//         return {} as ISymbol[];
//       }
//     }),
//   );

// await qtApi.search.stock('couche tard');
// void qtApi;

// = [
/*
    argument of type '<R>(endpoint: string, handlerOptions: ProxyHandlerOptions) => () => Promise<R>'
    is not assignable to
    parameter of type '<R>(endpoint: string) => () => Promise<R>'.ts(2345)
    ,
    handlerOptions: ProxyHandlerOptions,
    , { noCaching: true }
     */
// _getAccounts(getApi(), errorlog),
// _getActivities(accGetApi(), errorlog),
// _getBalances(accGetApi(), errorlog),
// _getCandles(getApi(), errorlog),
// _getExecutions(accGetApi(), errorlog),
// _getMarkets(getApi(), errorlog),
// _getMarketsQuotesStrategies(postApi(), errorlog),
// _getOptionsById(getApi(), errorlog),
// _getOrders(accGetApi(), errorlog),
// _getOrdersByIds(accGetApi(), errorlog),
// _getPositions(accGetApi(), errorlog),
// _getQuotesByIds(getApi(), errorlog),
// // _getQuotesOptionsbyFilterAndIds(credentials,proxy, errorlog),
// _getQuotesOptionsByIds(postApi(), errorlog),
// _getQuotesOptionsFilter(
//   postApi() /* , errorlog */,
// ),
// _getServerTime(getApi() /* , errorlog */),
// _getSymbolsByIds(getApi(), errorlog),
// _getSymbolSearchAll(getApi(), errorlog),
// // _getSymbolSearchAndCount(credentials,proxy, errorlog),
// _getSymbolSearch(getApi(), errorlog),
// _getSymbolSearchCount(getApi(), errorlog),
// ];
// unused for the moment
// symbolSearchAndCount:    // _getSymbolSearchAndCount(credentials,proxy, errorlog),
// quotesOptionsbyFilterAndIds:    // _getQuotesOptionsbyFilterAndIds(credentials,proxy, errorlog),
