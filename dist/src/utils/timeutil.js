"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.now = exports.setDateRange = exports.dateRange = exports.dateRangeFromNow = exports.dateToNumeric = exports.dateToISOString = exports.dateNowNumeric = exports.dateNowISO = exports.urlEncodeDateTool = exports.getDateRange = exports.DateClass = exports.DateInterval = exports.dayMiliseconds = void 0;
const _1 = require(".");
const DAY = 24 * 60 * 60 * 1000;
const dayMiliseconds = (days) => days * DAY;
exports.dayMiliseconds = dayMiliseconds;
class DateInterval {
}
exports.DateInterval = DateInterval;
class DateClass {
    constructor(year, month, day, hours, minutes) {
        Object.defineProperty(this, "date", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.date = new Date(year, month - 1, day, hours || 0, minutes || 0);
        void this;
    }
    get getDate() {
        return this.date.toISOString();
    }
}
exports.DateClass = DateClass;
function getDateRange(date, offset) {
    let startDate = new Date(date).toISOString();
    let endDate = new Date(date).toISOString();
    const newDate = new Date(new Date(date).valueOf() + exports.dayMiliseconds(offset)).toISOString();
    if (offset > 0) {
        startDate = new Date(date).toISOString();
        endDate = newDate;
    }
    if (offset < 0) {
        endDate = new Date(date).toISOString();
        startDate = newDate;
    }
    return { endDate, startDate };
}
exports.getDateRange = getDateRange;
// new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])
// export function timeUtil() {
//   //
// }
// let startDate = '2019-08-25';
// let endDate = '2019-09-14T00:00:00.000000-05:00';
// const now = Date.now;
// export const dates = [
//   startDate,
//   new Date(now()).toISOString(),
//   new Date(now()).toUTCString(),
//   new Date(now()).toString(),
//   new Date(now()).toLocaleString(),
//   new Date(now()).toJSON(),
//   new Date(startDate).toISOString(),
//   new Date(startDate).toUTCString(),
//   new Date(endDate).toString(),
//   new Date(startDate).toLocaleString(),
//   new Date(startDate).toJSON(),
// ];
// const offset = 9;
// startDate = `2019-${offset}-13`;
// endDate = `2019-${offset}-14`;
const urlEncodeDateTool = (startTime, endTime) => {
    return `startTime=${_1.urlEncode(exports.dateToISOString(startTime))}&endTime=${_1.urlEncode(exports.dateToISOString(endTime))}`;
};
exports.urlEncodeDateTool = urlEncodeDateTool;
const dateNowISO = () => new Date(Date.now()).toISOString();
exports.dateNowISO = dateNowISO;
const dateNowNumeric = () => new Date(Date.now()).getTime();
exports.dateNowNumeric = dateNowNumeric;
const dateToISOString = (dateTime) => new Date(dateTime).toISOString();
exports.dateToISOString = dateToISOString;
const dateToNumeric = (dateTime) => new Date(dateTime).getTime();
exports.dateToNumeric = dateToNumeric;
const dateRangeFromNow = (backNumberOfDays) => {
    const back = Math.floor(backNumberOfDays);
    const numberOfDays = back < 0 ? back * -1 : back;
    return exports.dateRange(numberOfDays, exports.dateNowISO());
};
exports.dateRangeFromNow = dateRangeFromNow;
const dateRange = (backNumberOfDays, dateNow) => {
    let now_ = dateNow;
    if (!now_) {
        now_ = exports.dateNowISO();
    }
    const startDate = rmvMiliSec(exports.dateToNumeric(now_) - exports.dayMiliseconds(backNumberOfDays));
    const endDate = rmvMiliSec(now_);
    const startTime = startDate;
    const endTime = endDate;
    return {
        endDate,
        endTime,
        startDate,
        startTime,
    };
};
exports.dateRange = dateRange;
const rmvMiliSec = (date) => {
    const { floor } = Math;
    return exports.dateToISOString(floor(exports.dateToNumeric(date) / 1000) * 1000);
};
const setDateRange = (backNumberOfDays) => (funct, fromDate) => {
    const { startTime, endTime } = exports.dateRange(backNumberOfDays, fromDate);
    return funct(startTime)(endTime);
};
exports.setDateRange = setDateRange;
function now() {
    return Date.now();
}
exports.now = now;
// export const rangeTool = (startTime?: string | null) => (
//   endTime?: string | null
// ) => (numberOfDays?: number | null) => {
//   const days = !!numberOfDays ? numberOfDays : 0;
//   const endValue = !endTime ? dateNumericNow() : dateToNumeric(endTime);
//   const startValue = !startTime ? dateNumericNow() : dateToNumeric(startTime);
//   return [dateToString(endValue), dateToString(startValue + day(days))];
// };
// const naiveCalculate = (SECOND: number = 1000) => {
//   const DAY = 24 * 60 * 60 * SECOND;
//   return {
//     sECOND,
//     hOUR: 60 * 60 * SECOND,
//     mINUTE: 60 * SECOND,
//     dAY,
//     wEEK5: 5 * DAY,
//     wEEK7: 7 * DAY,
//     mONTH: 31 * DAY,
//     mONTH28: 28 * DAY,
//     mONTH29: 29 * DAY,
//     mONTH30: 30 * DAY,
//     yEAR: 365 * DAY,
//     yEAR366: 366 * DAY,
//     yWEEKS: 52,
//     yMONTHS: 12,
//   };
// };
// export const naive = {
//   inSec: naiveCalculate(1),
//   inMiliSec: naiveCalculate(1000),
// };
// export const naiveSecondes = naive(1);
// export const naiveMiliSecondes = naive(1000);
// endpointFormatDateTool(startTime, endTime);
// import { questrade } from "../../classes/questradeBase";
// questrade("0I55OUTM7zHQZbG9AiwA5vY3zQY6W6qt0").then(
//   async will => console.log(will)
// await will.get.orders(startDate, endDate)(), // .reduce(
// will.get.current.accountNumber(),
// will.get.markets
// await will.get.supported.markets(),
// await will.get.market.quotes([9292, 9292])
// (pre: number, curent, _index) =>
// {
//   const void0: unknown =
//   if (!!curent.commission.valueOf())
//   return curent.commission + pre;
//  },
// 0
// ()
// );
// );
// date :
// day
// month
// year
// 2014-01-02T00:00:00.000000-05:00
// 2019-09-14T09:07:37.461Z
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZXV0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvdGltZXV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsd0JBQThCO0FBRTlCLE1BQU0sR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztBQUV6QixNQUFNLGNBQWMsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUE5QyxRQUFBLGNBQWMsa0JBQWdDO0FBRTNELE1BQWEsWUFBWTtDQUFHO0FBQTVCLG9DQUE0QjtBQUU1QixNQUFhLFNBQVM7SUFPcEIsWUFDRSxJQUFZLEVBQ1osS0FBYSxFQUNiLEdBQVcsRUFDWCxLQUFjLEVBQ2QsT0FBZ0I7UUFYbEI7Ozs7O1dBQW1CO1FBYWpCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3JFLEtBQUssSUFBSSxDQUFDO0lBQ1osQ0FBQztJQWJELElBQVcsT0FBTztRQUNoQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDakMsQ0FBQztDQVlGO0FBakJELDhCQWlCQztBQUVELFNBQWdCLFlBQVksQ0FDMUIsSUFBbUIsRUFDbkIsTUFBYztJQUVkLElBQUksU0FBUyxHQUFrQixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM1RCxJQUFJLE9BQU8sR0FBa0IsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDMUQsTUFBTSxPQUFPLEdBQWtCLElBQUksSUFBSSxDQUNyQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVB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QUFDYixjQUFjO0FBQ2QsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQixXQUFXO0FBQ1gsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLE9BQU87QUFDUCxLQUFLO0FBQ0wseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5QixxQ0FBcUM7QUFDckMsS0FBSztBQUNMLHlDQUF5QztBQUN6QyxnREFBZ0Q7QUFFaEQsOENBQThDO0FBRTlDLDJEQUEyRDtBQUMzRCx1REFBdUQ7QUFDdkQsb0NBQW9DO0FBQ3BDLDJEQUEyRDtBQUMzRCxvQ0FBb0M7QUFDcEMsbUJBQW1CO0FBQ25CLHNDQUFzQztBQUN0Qyw2Q0FBNkM7QUFDN0MsbUNBQW1DO0FBQ25DLElBQUk7QUFDSiwyQkFBMkI7QUFDM0IsdUNBQXVDO0FBQ3ZDLG9DQUFvQztBQUNwQyxNQUFNO0FBQ04sSUFBSTtBQUNKLEtBQUs7QUFDTCxLQUFLO0FBQ0wsS0FBSztBQUNMLFNBQVM7QUFDVCxNQUFNO0FBQ04sUUFBUTtBQUNSLE9BQU87QUFDUCxtQ0FBbUM7QUFDbkMsMkJBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cbmltcG9ydCB7IERhdGVUaW1lUmFuZ2UgfSBmcm9tICcuLi90eXBlc2NyaXB0JztcbmltcG9ydCB7IHVybEVuY29kZSB9IGZyb20gJy4nO1xuXG5jb25zdCBEQVkgPSAyNCAqIDYwICogNjAgKiAxMDAwO1xuXG5leHBvcnQgY29uc3QgZGF5TWlsaXNlY29uZHMgPSAoZGF5czogbnVtYmVyKSA9PiBkYXlzICogREFZO1xuXG5leHBvcnQgY2xhc3MgRGF0ZUludGVydmFsIHt9XG5cbmV4cG9ydCBjbGFzcyBEYXRlQ2xhc3Mge1xuICBwcml2YXRlIGRhdGU6IERhdGU7XG5cbiAgcHVibGljIGdldCBnZXREYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGUudG9JU09TdHJpbmcoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHllYXI6IG51bWJlcixcbiAgICBtb250aDogbnVtYmVyLFxuICAgIGRheTogbnVtYmVyLFxuICAgIGhvdXJzPzogbnVtYmVyLFxuICAgIG1pbnV0ZXM/OiBudW1iZXIsXG4gICkge1xuICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VycyB8fCAwLCBtaW51dGVzIHx8IDApO1xuICAgIHZvaWQgdGhpcztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0ZVJhbmdlKFxuICBkYXRlOiBEYXRlIHwgc3RyaW5nLFxuICBvZmZzZXQ6IG51bWJlcixcbik6IERhdGVUaW1lUmFuZ2Uge1xuICBsZXQgc3RhcnREYXRlOiBEYXRlIHwgc3RyaW5nID0gbmV3IERhdGUoZGF0ZSkudG9JU09TdHJpbmcoKTtcbiAgbGV0IGVuZERhdGU6IERhdGUgfCBzdHJpbmcgPSBuZXcgRGF0ZShkYXRlKS50b0lTT1N0cmluZygpO1xuICBjb25zdCBuZXdEYXRlOiBEYXRlIHwgc3RyaW5nID0gbmV3IERhdGUoXG4gICAgbmV3IERhdGUoZGF0ZSkudmFsdWVPZigpICsgZGF5TWlsaXNlY29uZHMob2Zmc2V0KSxcbiAgKS50b0lTT1N0cmluZygpO1xuXG4gIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgc3RhcnREYXRlID0gbmV3IERhdGUoZGF0ZSkudG9JU09TdHJpbmcoKTtcbiAgICBlbmREYXRlID0gbmV3RGF0ZTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgZW5kRGF0ZSA9IG5ldyBEYXRlKGRhdGUpLnRvSVNPU3RyaW5nKCk7XG4gICAgc3RhcnREYXRlID0gbmV3RGF0ZTtcbiAgfVxuXG4gIHJldHVybiB7IGVuZERhdGUsIHN0YXJ0RGF0ZSB9O1xufVxuXG4vLyBuZXcgRGF0ZSh5ZWFyLCBtb250aEluZGV4IFssIGRheSBbLCBob3VycyBbLCBtaW51dGVzIFssIHNlY29uZHMgWywgbWlsbGlzZWNvbmRzXV1dXV0pXG5cbi8vIGV4cG9ydCBmdW5jdGlvbiB0aW1lVXRpbCgpIHtcbi8vICAgLy9cbi8vIH1cbi8vIGxldCBzdGFydERhdGUgPSAnMjAxOS0wOC0yNSc7XG4vLyBsZXQgZW5kRGF0ZSA9ICcyMDE5LTA5LTE0VDAwOjAwOjAwLjAwMDAwMC0wNTowMCc7XG4vLyBjb25zdCBub3cgPSBEYXRlLm5vdztcbi8vIGV4cG9ydCBjb25zdCBkYXRlcyA9IFtcbi8vICAgc3RhcnREYXRlLFxuLy8gICBuZXcgRGF0ZShub3coKSkudG9JU09TdHJpbmcoKSxcbi8vICAgbmV3IERhdGUobm93KCkpLnRvVVRDU3RyaW5nKCksXG4vLyAgIG5ldyBEYXRlKG5vdygpKS50b1N0cmluZygpLFxuLy8gICBuZXcgRGF0ZShub3coKSkudG9Mb2NhbGVTdHJpbmcoKSxcbi8vICAgbmV3IERhdGUobm93KCkpLnRvSlNPTigpLFxuLy8gICBuZXcgRGF0ZShzdGFydERhdGUpLnRvSVNPU3RyaW5nKCksXG4vLyAgIG5ldyBEYXRlKHN0YXJ0RGF0ZSkudG9VVENTdHJpbmcoKSxcbi8vICAgbmV3IERhdGUoZW5kRGF0ZSkudG9TdHJpbmcoKSxcbi8vICAgbmV3IERhdGUoc3RhcnREYXRlKS50b0xvY2FsZVN0cmluZygpLFxuLy8gICBuZXcgRGF0ZShzdGFydERhdGUpLnRvSlNPTigpLFxuLy8gXTtcbi8vIGNvbnN0IG9mZnNldCA9IDk7XG4vLyBzdGFydERhdGUgPSBgMjAxOS0ke29mZnNldH0tMTNgO1xuLy8gZW5kRGF0ZSA9IGAyMDE5LSR7b2Zmc2V0fS0xNGA7XG5cbmV4cG9ydCBjb25zdCB1cmxFbmNvZGVEYXRlVG9vbCA9IChcbiAgc3RhcnRUaW1lOiBzdHJpbmcsXG4gIGVuZFRpbWU6IHN0cmluZyxcbik6IHN0cmluZyA9PiB7XG4gIHJldHVybiBgc3RhcnRUaW1lPSR7dXJsRW5jb2RlKFxuICAgIGRhdGVUb0lTT1N0cmluZyhzdGFydFRpbWUpLFxuICApfSZlbmRUaW1lPSR7dXJsRW5jb2RlKGRhdGVUb0lTT1N0cmluZyhlbmRUaW1lKSl9YDtcbn07XG5cbmV4cG9ydCBjb25zdCBkYXRlTm93SVNPID0gKCkgPT4gbmV3IERhdGUoRGF0ZS5ub3coKSkudG9JU09TdHJpbmcoKTtcbmV4cG9ydCBjb25zdCBkYXRlTm93TnVtZXJpYyA9ICgpID0+IG5ldyBEYXRlKERhdGUubm93KCkpLmdldFRpbWUoKTtcblxuZXhwb3J0IGNvbnN0IGRhdGVUb0lTT1N0cmluZyA9IChkYXRlVGltZTogRGF0ZSB8IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PlxuICBuZXcgRGF0ZShkYXRlVGltZSkudG9JU09TdHJpbmcoKTtcblxuZXhwb3J0IGNvbnN0IGRhdGVUb051bWVyaWMgPSAoZGF0ZVRpbWU6IERhdGUgfCBudW1iZXIgfCBzdHJpbmcpOiBudW1iZXIgPT5cbiAgbmV3IERhdGUoZGF0ZVRpbWUpLmdldFRpbWUoKTtcbmV4cG9ydCBjb25zdCBkYXRlUmFuZ2VGcm9tTm93ID0gKGJhY2tOdW1iZXJPZkRheXM6IG51bWJlcikgPT4ge1xuICBjb25zdCBiYWNrID0gTWF0aC5mbG9vcihiYWNrTnVtYmVyT2ZEYXlzKTtcbiAgY29uc3QgbnVtYmVyT2ZEYXlzID0gYmFjayA8IDAgPyBiYWNrICogLTEgOiBiYWNrO1xuXG4gIHJldHVybiBkYXRlUmFuZ2UobnVtYmVyT2ZEYXlzLCBkYXRlTm93SVNPKCkpO1xufTtcblxudHlwZSBTdGFydERhdGUgPSBzdHJpbmc7XG50eXBlIEVuZERhdGUgPSBzdHJpbmc7XG5pbnRlcmZhY2UgU3RhcnREYXRlRW5kRGF0ZU9iamVjdCB7XG4gIHN0YXJ0RGF0ZTogU3RhcnREYXRlO1xuICBzdGFydFRpbWU6IFN0YXJ0RGF0ZTtcbiAgZW5kRGF0ZTogRW5kRGF0ZTtcbiAgZW5kVGltZTogRW5kRGF0ZTtcbn1cbmV4cG9ydCBjb25zdCBkYXRlUmFuZ2UgPSAoXG4gIGJhY2tOdW1iZXJPZkRheXM6IG51bWJlcixcbiAgZGF0ZU5vdz86IHN0cmluZyxcbik6IFN0YXJ0RGF0ZUVuZERhdGVPYmplY3QgPT4ge1xuICBsZXQgbm93XyA9IGRhdGVOb3c7XG5cbiAgaWYgKCFub3dfKSB7XG4gICAgbm93XyA9IGRhdGVOb3dJU08oKTtcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0RGF0ZTogU3RhcnREYXRlID0gcm12TWlsaVNlYyhcbiAgICBkYXRlVG9OdW1lcmljKG5vd18pIC0gZGF5TWlsaXNlY29uZHMoYmFja051bWJlck9mRGF5cyksXG4gICk7XG5cbiAgY29uc3QgZW5kRGF0ZTogRW5kRGF0ZSA9IHJtdk1pbGlTZWMobm93Xyk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHN0YXJ0RGF0ZTtcbiAgY29uc3QgZW5kVGltZSA9IGVuZERhdGU7XG5cbiAgcmV0dXJuIHtcbiAgICBlbmREYXRlLFxuICAgIGVuZFRpbWUsXG4gICAgc3RhcnREYXRlLFxuICAgIHN0YXJ0VGltZSxcbiAgfTtcbn07XG5cbmNvbnN0IHJtdk1pbGlTZWMgPSAoZGF0ZTogRGF0ZSB8IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHsgZmxvb3IgfSA9IE1hdGg7XG5cbiAgcmV0dXJuIGRhdGVUb0lTT1N0cmluZyhmbG9vcihkYXRlVG9OdW1lcmljKGRhdGUpIC8gMTAwMCkgKiAxMDAwKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzZXREYXRlUmFuZ2UgPSAoYmFja051bWJlck9mRGF5czogbnVtYmVyKSA9PiA8VD4oXG4gIGZ1bmN0OiAoc3RhcnRUaW1lOiBzdHJpbmcpID0+IChlbmRUaW1lOiBzdHJpbmcpID0+IFQsXG4gIGZyb21EYXRlPzogc3RyaW5nLFxuKSA9PiB7XG4gIGNvbnN0IHsgc3RhcnRUaW1lLCBlbmRUaW1lIH0gPSBkYXRlUmFuZ2UoYmFja051bWJlck9mRGF5cywgZnJvbURhdGUpO1xuXG4gIHJldHVybiBmdW5jdChzdGFydFRpbWUpKGVuZFRpbWUpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIERhdGUubm93KCk7XG59XG5cbi8vIGV4cG9ydCBjb25zdCByYW5nZVRvb2wgPSAoc3RhcnRUaW1lPzogc3RyaW5nIHwgbnVsbCkgPT4gKFxuLy8gICBlbmRUaW1lPzogc3RyaW5nIHwgbnVsbFxuLy8gKSA9PiAobnVtYmVyT2ZEYXlzPzogbnVtYmVyIHwgbnVsbCkgPT4ge1xuLy8gICBjb25zdCBkYXlzID0gISFudW1iZXJPZkRheXMgPyBudW1iZXJPZkRheXMgOiAwO1xuLy8gICBjb25zdCBlbmRWYWx1ZSA9ICFlbmRUaW1lID8gZGF0ZU51bWVyaWNOb3coKSA6IGRhdGVUb051bWVyaWMoZW5kVGltZSk7XG4vLyAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhc3RhcnRUaW1lID8gZGF0ZU51bWVyaWNOb3coKSA6IGRhdGVUb051bWVyaWMoc3RhcnRUaW1lKTtcblxuLy8gICByZXR1cm4gW2RhdGVUb1N0cmluZyhlbmRWYWx1ZSksIGRhdGVUb1N0cmluZyhzdGFydFZhbHVlICsgZGF5KGRheXMpKV07XG4vLyB9O1xuXG4vLyBjb25zdCBuYWl2ZUNhbGN1bGF0ZSA9IChTRUNPTkQ6IG51bWJlciA9IDEwMDApID0+IHtcbi8vICAgY29uc3QgREFZID0gMjQgKiA2MCAqIDYwICogU0VDT05EO1xuLy8gICByZXR1cm4ge1xuLy8gICAgIHNFQ09ORCxcbi8vICAgICBoT1VSOiA2MCAqIDYwICogU0VDT05ELFxuLy8gICAgIG1JTlVURTogNjAgKiBTRUNPTkQsXG4vLyAgICAgZEFZLFxuLy8gICAgIHdFRUs1OiA1ICogREFZLFxuLy8gICAgIHdFRUs3OiA3ICogREFZLFxuLy8gICAgIG1PTlRIOiAzMSAqIERBWSxcbi8vICAgICBtT05USDI4OiAyOCAqIERBWSxcbi8vICAgICBtT05USDI5OiAyOSAqIERBWSxcbi8vICAgICBtT05USDMwOiAzMCAqIERBWSxcbi8vICAgICB5RUFSOiAzNjUgKiBEQVksXG4vLyAgICAgeUVBUjM2NjogMzY2ICogREFZLFxuLy8gICAgIHlXRUVLUzogNTIsXG4vLyAgICAgeU1PTlRIUzogMTIsXG4vLyAgIH07XG4vLyB9O1xuLy8gZXhwb3J0IGNvbnN0IG5haXZlID0ge1xuLy8gICBpblNlYzogbmFpdmVDYWxjdWxhdGUoMSksXG4vLyAgIGluTWlsaVNlYzogbmFpdmVDYWxjdWxhdGUoMTAwMCksXG4vLyB9O1xuLy8gZXhwb3J0IGNvbnN0IG5haXZlU2Vjb25kZXMgPSBuYWl2ZSgxKTtcbi8vIGV4cG9ydCBjb25zdCBuYWl2ZU1pbGlTZWNvbmRlcyA9IG5haXZlKDEwMDApO1xuXG4vLyBlbmRwb2ludEZvcm1hdERhdGVUb29sKHN0YXJ0VGltZSwgZW5kVGltZSk7XG5cbi8vIGltcG9ydCB7IHF1ZXN0cmFkZSB9IGZyb20gXCIuLi8uLi9jbGFzc2VzL3F1ZXN0cmFkZUJhc2VcIjtcbi8vIHF1ZXN0cmFkZShcIjBJNTVPVVRNN3pIUVpiRzlBaXdBNXZZM3pRWTZXNnF0MFwiKS50aGVuKFxuLy8gICBhc3luYyB3aWxsID0+IGNvbnNvbGUubG9nKHdpbGwpXG4vLyBhd2FpdCB3aWxsLmdldC5vcmRlcnMoc3RhcnREYXRlLCBlbmREYXRlKSgpLCAvLyAucmVkdWNlKFxuLy8gd2lsbC5nZXQuY3VycmVudC5hY2NvdW50TnVtYmVyKCksXG4vLyB3aWxsLmdldC5tYXJrZXRzXG4vLyBhd2FpdCB3aWxsLmdldC5zdXBwb3J0ZWQubWFya2V0cygpLFxuLy8gYXdhaXQgd2lsbC5nZXQubWFya2V0LnF1b3RlcyhbOTI5MiwgOTI5Ml0pXG4vLyAocHJlOiBudW1iZXIsIGN1cmVudCwgX2luZGV4KSA9PlxuLy8ge1xuLy8gICBjb25zdCB2b2lkMDogdW5rbm93biA9XG4vLyAgIGlmICghIWN1cmVudC5jb21taXNzaW9uLnZhbHVlT2YoKSlcbi8vICAgcmV0dXJuIGN1cmVudC5jb21taXNzaW9uICsgcHJlO1xuLy8gIH0sXG4vLyAwXG4vLyAoKVxuLy8gKTtcbi8vICk7XG4vLyBkYXRlIDpcbi8vIGRheVxuLy8gbW9udGhcbi8vIHllYXJcbi8vIDIwMTQtMDEtMDJUMDA6MDA6MDAuMDAwMDAwLTA1OjAwXG4vLyAyMDE5LTA5LTE0VDA5OjA3OjM3LjQ2MVpcbiJdfQ==